diff a/core/image_stream_bridge.py b/core/image_stream_bridge.py	(rejected hunks)
@@ -1,102 +1,120 @@
-# core/image_stream_bridge.py
+# core/image_stream_bridge.py
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
 import io
 import os
 import socket
 import struct
 import threading
 import time
 import datetime
 from typing import Callable, Optional, Dict, Any
 
 try:
     from PIL import Image  # 미리보기 썸네일 생성에 사용될 수 있음(옵션)
     _HAS_PIL = True
 except Exception:
     _HAS_PIL = False
 
 
 # ---- Command IDs (MroCameraControl) ----
 CMD_REQ_CAPTURE      = 0x01
 CMD_SET_GIMBAL       = 0x02  # 예약
 CMD_SET_COUNT        = 0x03
 CMD_GET_IMG_NUM      = 0x04
 CMD_REQ_SEND_IMG     = 0x05
 CMD_IMG_NUM_RESPONSE = 0x11
 CMD_FILE_IMG_TRANSFER= 0x12
 
 
-class ImageBridgeCore:
-    """
+__all__ = ["ImageStreamBridge"]
+
+
+class ImageStreamBridge:
+    """Image stream module for MRO UnifiedBridge (통합브릿지).
+
+    MRO UnifiedBridge를 구성하는 세 모듈 중 영상 스트리밍 담당 파트로,
+    실시간 UDP 프레임을 조립하고 TCP 명령(캡처/파일 전송 등)에 대응한다.
+    SaveFile(실시간 캡처) 또는 PreDefinedImageSet(사전 이미지) 중 선택된
+    라이브러리를 사용해 TCP 클라이언트에 이미지를 제공한다.
+
     - TCP 서버: MroCameraControl 명령 송수신
     - UDP 수신: New ICD(30B 헤더) 기반 JPEG 조립
-    - 콜백:
-        log_cb(text), preview_cb(jpeg_bytes), status_cb(text)
+    - 이미지 라이브러리 선택: realtime(SaveFile) / predefined(PreDefinedImageSet)
+    - 콜백: log_cb(text), preview_cb(jpeg_bytes), status_cb(text)
     """
 
     def __init__(
         self,
         log_cb: Callable[[str], None],
         preview_cb: Optional[Callable[[bytes], None]],
         status_cb: Optional[Callable[[str], None]],
         settings: Dict[str, Any],
     ) -> None:
         self.log = log_cb
         self.preview_cb = preview_cb
         self.status_cb = status_cb
 
         # settings
         self.ip = settings.get("ip", "0.0.0.0")
         self.tcp_port = int(settings.get("tcp_port", 9999))
         self.udp_port = int(settings.get("udp_port", 9998))
-        self.images_dir = str(settings.get("images", "./images"))
+        self.realtime_dir = str(
+            settings.get(
+                "realtime_dir",
+                settings.get("images", "./SaveFile"),
+            )
+        )
+        self.predefined_dir = str(settings.get("predefined_dir", "./PreDefinedImageSet"))
+        self.image_source_mode = self._sanitize_mode(settings.get("image_source_mode", "realtime"))
 
         # runtime
         self.is_server_running = threading.Event()
         self._tcp_sock: Optional[socket.socket] = None
         self._udp_sock: Optional[socket.socket] = None
         self._client_conn: Optional[socket.socket] = None
 
         self._tcp_thread: Optional[threading.Thread] = None
         self._udp_thread: Optional[threading.Thread] = None
 
         self._lock = threading.Lock()
         self._latest_jpeg: Optional[bytes] = None
         self._next_image_number: int = 0  # 다음 저장 번호 (000..999 롤링)
 
         # UDP reassembly buffer
         self._reasm: Optional[Dict[str, Any]] = None
         self._last_image_meta = {
             "kb": 0.0,
             "received_at": None,   # datetime or None
             "saved_path": None,    # 마지막으로 디스크에 쓴 파일 경로
         }
 
         self._prepare_dirs()
+        self._sync_next_number()
+        self._predefined_numbers = self._scan_predefined_numbers()
 
     # --------------- lifecycle ---------------
 
     def start(self) -> None:
         if self.is_server_running.is_set():
             return
         self.is_server_running.set()
         self._open_tcp()
         self._open_udp()
         self._tcp_thread = threading.Thread(target=self._tcp_server_thread, daemon=True)
         self._udp_thread = threading.Thread(target=self._udp_receiver_thread, daemon=True)
         self._tcp_thread.start()
         self._udp_thread.start()
         self._emit_status("RUNNING")
         self.log(f"[BRIDGE] started at {self.ip} TCP:{self.tcp_port} UDP:{self.udp_port}")
 
     def stop(self) -> None:
         if not self.is_server_running.is_set():
             return
         self.is_server_running.clear()
 
         # close client first
         if self._client_conn:
             try:
                 self._client_conn.shutdown(socket.SHUT_RDWR)
