diff a/core/image_stream_bridge.py b/core/image_stream_bridge.py	(rejected hunks)
@@ -1,56 +1,59 @@
 # core/image_stream_bridge.py
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
 import io
 import os
 import socket
 import struct
 import threading
 import time
 import datetime
 from typing import Callable, Optional, Dict, Any
 
 try:
     from PIL import Image  # 미리보기 썸네일 생성에 사용될 수 있음(옵션)
     _HAS_PIL = True
 except Exception:
     _HAS_PIL = False
 
 
 # ---- Command IDs (MroCameraControl) ----
-CMD_REQ_CAPTURE       = 0x01
-CMD_SET_GIMBAL        = 0x02  # 예약
-CMD_SET_COUNT         = 0x03
-CMD_GET_IMG_NUM       = 0x04
-CMD_REQ_SEND_IMG      = 0x05
-CMD_SET_ZOOM_RATIO    = 0x06
-CMD_GET_ZOOM_RATIO    = 0x07
-CMD_IMG_NUM_RESPONSE  = 0x11
-CMD_FILE_IMG_TRANSFER = 0x12
-CMD_ACK_ZOOM_RATIO    = 0x13
+from network.image_stream_icd import (
+    CMD_REQ_CAPTURE,
+    CMD_SET_GIMBAL,
+    CMD_SET_COUNT,
+    CMD_GET_IMG_NUM,
+    CMD_REQ_SEND_IMG,
+    CMD_SET_ZOOM_RATIO,
+    CMD_GET_ZOOM_RATIO,
+    CMD_IMG_NUM_RESPONSE,
+    CMD_FILE_IMG_TRANSFER,
+    CMD_ACK_ZOOM_RATIO,
+    COMMAND_NAMES,
+)
 
 
 __all__ = ["ImageStreamBridge", "ImageBridgeCore"]
 
 
 class ImageStreamBridge:
     """Image stream module for MRO UnifiedBridge (통합브릿지).
 
     MRO UnifiedBridge를 구성하는 세 모듈 중 영상 스트리밍 담당 파트로,
     실시간 UDP 프레임을 조립하고 TCP 명령(캡처/파일 전송 등)에 대응한다.
     SaveFile(실시간 캡처) 또는 PreDefinedImageSet(사전 이미지) 중 선택된
     라이브러리를 사용해 TCP 클라이언트에 이미지를 제공한다.
 
     - TCP 서버: MroCameraControl 명령 송수신
     - UDP 수신: New ICD(30B 헤더) 기반 JPEG 조립
     - 이미지 라이브러리 선택: realtime(SaveFile) / predefined(PreDefinedImageSet)
     - 콜백: log_cb(text), preview_cb(jpeg_bytes), status_cb(text)
     """
 
     def __init__(
         self,
         log_cb: Callable[[str], None],
         preview_cb: Optional[Callable[[bytes], None]],
         status_cb: Optional[Callable[[str], None]],
         settings: Dict[str, Any],
@@ -216,107 +219,109 @@ class ImageStreamBridge:
                     break
                 payload_len = struct.unpack("<I", header)[0]
                 payload = self._recv_all(conn, payload_len)
                 if not payload or len(payload) != payload_len:
                     self.log("[BRIDGE] TCP payload length mismatch")
                     break
                 self._process_command(payload, conn)
         except Exception as e:
             self.log(f"[BRIDGE] client error: {e}")
         finally:
             try:
                 conn.close()
             except Exception:
                 pass
             self._client_conn = None
             self.log("[BRIDGE] TCP client disconnected")
             
     def _process_command(self, payload: bytes, conn: socket.socket) -> None:
         # [ts_sec(4)][ts_nsec(4)][cmd_id(1)] + payload...
         if len(payload) < 9:
             self.log("[BRIDGE] malformed cmd payload")
             return
         ts_sec, ts_nsec, cmd_id = struct.unpack("<IIB", payload[:9])
         cmd_payload = payload[9:]
 
-        def _expect_uint8_one(p: bytes, cmd_name: str) -> bool:
+        cmd_name = COMMAND_NAMES.get(cmd_id, f"0x{cmd_id:02X}")
+
+        def _expect_uint8_one(p: bytes, name: str) -> bool:
             """uint8==1 규격을 검증. 없거나 값이 1이 아니면 경고 로그."""
             if len(p) < 1:
-                self.log(f"[BRIDGE] {cmd_name}: missing uint8 payload; treating as 1 for backward-compat")
+                self.log(f"[BRIDGE] {name}: missing uint8 payload; treating as 1 for backward-compat")
                 return True  # 하위호환을 위해 허용
             (flag,) = struct.unpack("<B", p[:1])
             if flag != 1:
-                self.log(f"[BRIDGE] {cmd_name}: expected uint8==1, got {flag}; ignoring but continuing")
+                self.log(f"[BRIDGE] {name}: expected uint8==1, got {flag}; ignoring but continuing")
             return True
 
         if cmd_id == CMD_REQ_CAPTURE:
             # 기대 페이로드: uint8==1 (1바이트)
-            _expect_uint8_one(cmd_payload, "Req_Capture")
+            _expect_uint8_one(cmd_payload, cmd_name)
             self._handle_req_capture()
 
         elif cmd_id == CMD_SET_COUNT:
             if len(cmd_payload) >= 4:
                 (count_num,) = struct.unpack("<I", cmd_payload[:4])
                 self._handle_set_count(count_num)
             else:
-                self.log("[BRIDGE] Set_Count: missing uint32 count_num")
+                self.log(f"[BRIDGE] {cmd_name}: missing uint32 count_num")
 
         elif cmd_id == CMD_GET_IMG_NUM:
             # 기대 페이로드: uint8==1 (1바이트)
-            _expect_uint8_one(cmd_payload, "Get_ImgNum")
+            _expect_uint8_one(cmd_payload, cmd_name)
             self._handle_get_img_num(conn)
 
         elif cmd_id == CMD_REQ_SEND_IMG:
             if len(cmd_payload) >= 4:
                 (img_num,) = struct.unpack("<I", cmd_payload[:4])
                 self._handle_req_send_img(conn, img_num)
             else:
-                self.log("[BRIDGE] Req_SendImg: missing uint32 img_num")
+                self.log(f"[BRIDGE] {cmd_name}: missing uint32 img_num")
 
         elif cmd_id == CMD_SET_GIMBAL:
-            self.log("[BRIDGE] Set_Gimbal received (reserved)")
+            self.log(f"[BRIDGE] {cmd_name} received (reserved)")
 
         elif cmd_id == CMD_SET_ZOOM_RATIO:
             if len(cmd_payload) < 4:
-                self.log("[BRIDGE] Set_Zoomratio: missing float zoom_ratio")
+                self.log(f"[BRIDGE] {cmd_name}: missing float zoom_ratio")
                 return
             (zoom_ratio,) = struct.unpack("<f", cmd_payload[:4])
             self.set_zoom_scale(zoom_ratio)
             with self._lock:
                 applied = self._zoom_scale
-            self.log(f"[BRIDGE] Set_Zoomratio -> request={zoom_ratio:.3f}, applied={applied:.3f}")
+            self.log(f"[BRIDGE] {cmd_name} -> request={zoom_ratio:.3f}, applied={applied:.3f}")
             self._send_zoom_ratio_ack(conn, applied)
 
         elif cmd_id == CMD_GET_ZOOM_RATIO:
-            _expect_uint8_one(cmd_payload, "Get_Zoomratio")
+            _expect_uint8_one(cmd_payload, cmd_name)
             with self._lock:
                 applied = self._zoom_scale
-            self.log(f"[BRIDGE] Get_Zoomratio -> {applied:.3f}")
+            self.log(f"[BRIDGE] {cmd_name} -> {applied:.3f}")
             self._send_zoom_ratio_ack(conn, applied)
 
         else:
-            self.log(f"[BRIDGE] unknown cmd_id: 0x{cmd_id:02X}")
+            self.log(f"[BRIDGE] unknown cmd_id: {cmd_name}")
 
     def _handle_req_capture(self) -> None:
         with self._lock:
             if not self._latest_jpeg:
                 self.log("[BRIDGE] no image to capture (UDP not received yet)")
                 return
             fn = os.path.join(self.realtime_dir, f"{self._next_image_number:03d}.jpg")
             try:
                 with open(fn, "wb") as f:
                     f.write(self._latest_jpeg)
                 # 로그/상태 갱신
                 self._last_image_meta["saved_path"] = fn
                 self.log(f"[BRIDGE] saved image: {fn} | next_num(before)={self._next_image_number:03d}")
                 self._next_image_number = (self._next_image_number + 1) % 1000
                 self.log(f"[BRIDGE] next image number -> {self._next_image_number:03d}")
             except Exception as e:
                 self.log(f"[BRIDGE] file write error: {e}")
 
     def _handle_set_count(self, count_num: int) -> None:
         with self._lock:
             self._next_image_number = count_num % 1000
         self.log(f"[BRIDGE] next image number set to {self._next_image_number:03d}")
 
     def _handle_get_img_num(self, conn: socket.socket) -> None:
         with self._lock:
